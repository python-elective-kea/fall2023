<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Programming Paradigms &mdash; Introduction to python 1.0.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Introduction to python
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About this elective</a></li>
<li class="toctree-l1"><a class="reference internal" href="../exam.html">Exam</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses1.html">Session 1 - Introduction to python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses2.html">Session 2 - Data Structures: List &amp; Tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses4.html">Session 3 - Mandatory assignment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses3.html">Session 4 - Modules &amp; list comprehensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses5.html">Session 5 - Utilities and Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses6.html">Session 6 - Functions &amp;  Decorators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses7.html">Session 7 - Pythonic OOP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses8.html">Session 8 - Encapsulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses9.html">Session 9 - The python datamodel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses10.html">Session 10 - Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses11.html">Session 11 - Context Managers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses12.html">Session 12 - Mandatory Assignment 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses14-15.html">Session 15 - Exam preperation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ses14-15.html">Session 15 - Exam preperation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Introduction to python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Programming Paradigms</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/python-elective-kea/fall2023/blob/master/source/notebooks/programming_paradigms.md" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="programming-paradigms">
<h1>Programming Paradigms<a class="headerlink" href="#programming-paradigms" title="Permalink to this heading"></a></h1>
<p>::: abstract
Do you solve problems by just jumping in, willing to ignore the
experience and wisdom of those that may have programmed solutions to
problems very similar to yours? We learn from the past. Our ancestors
discovered and invented ways of programming that we know call paradigms.
We benefit from the knowledge they left us, even as we strive to create
new paradigms ourselves.
:::</p>
<section id="definition">
<h2>Definition<a class="headerlink" href="#definition" title="Permalink to this heading"></a></h2>
<p>A [programming paradigm]{.dfn} is a style, or “way,” of programming.</p>
<p>Some languages make it easy to write in some paradigms but not others.</p>
<blockquote>
<div><p>Never use the phrase “programming <strong>language</strong> paradigm.”</p>
<p>A paradigm is a way of <strong>doing</strong> something (like programming), not a
concrete thing (like a language). Now, it’s true that if a programming
language L happens to make a particular programming paradigm P easy to
express, then we often say “L is a P language” (e.g. “Haskell is a
functional programming language”) but that does not mean there is any
such thing as a “functional language paradigm”.</p>
</div></blockquote>
</section>
<section id="some-common-paradigms">
<h2>Some Common Paradigms<a class="headerlink" href="#some-common-paradigms" title="Permalink to this heading"></a></h2>
<p>You should know these:</p>
<ul class="simple">
<li><p>[Imperative]{.dfn}: Programming with an explicit sequence of
commands that update state.</p></li>
<li><p>[Declarative]{.dfn}: Programming by specifying the result you want,
not how to get it.</p></li>
<li><p>[Structured]{.dfn}: Programming with clean, goto-free, nested
control structures.</p></li>
<li><p>[Procedural]{.dfn}: Imperative programming with procedure calls.</p></li>
<li><p>[Functional]{.dfn} (Applicative): Programming with function calls
that avoid any global state.</p></li>
<li><p>[Function-Level]{.dfn} (Combinator): Programming with no variables
at all.</p></li>
<li><p>[Object-Oriented]{.dfn}: Programming by defining objects that send
messages to each other. Objects have their own internal
(encapsulated) state and public interfaces. Object orientation can
be:</p>
<ul>
<li><p><strong>Class-based</strong>: Objects get state and behavior based on
membership in a class.</p></li>
<li><p><strong>Prototype-based</strong>: Objects get behavior from a prototype
object.</p></li>
</ul>
</li>
<li><p>[Event-Driven]{.dfn}: Programming with emitters and listeners of
asynchronous actions.</p></li>
<li><p>[Flow-Driven]{.dfn}: Programming processes communicating with each
other over predefined channels.</p></li>
<li><p>[Logic]{.dfn} (Rule-based): Programming by specifying a set of facts
and rules. An engine infers the answers to questions.</p></li>
<li><p>[Constraint]{.dfn}: Programming by specifying a set of constraints.
An engine finds the values that meet the constraints.</p></li>
<li><p>[Aspect-Oriented]{.dfn}: Programming cross-cutting concerns applied
transparently.</p></li>
<li><p>[Reflective]{.dfn}: Programming by manipulating the program elements
themselves.</p></li>
<li><p>[Array]{.dfn}: Programming with powerful array operators that
usually make loops unnecessary.</p></li>
</ul>
<p>Paradigms are <strong>not meant to be mutually exclusive</strong>; a single program
can feature multiple paradigms!</p>
<p>Make sure to check out <a class="reference external" href="http://en.wikipedia.org/wiki/Programming_paradigm">Wikipedia’s entry on Programming
Paradigms</a>.</p>
</section>
<section id="a-look-at-some-major-paradigms">
<h2>A Look At Some Major Paradigms<a class="headerlink" href="#a-look-at-some-major-paradigms" title="Permalink to this heading"></a></h2>
<section id="imperative-programming">
<h3>Imperative Programming<a class="headerlink" href="#imperative-programming" title="Permalink to this heading"></a></h3>
<p>Control flow in [imperative programming]{.dfn} is <em>explicit</em>: commands
show <em>how</em> the computation takes place, step by step. Each step affects
the global <strong>state</strong> of the computation.</p>
<div class="highlight-prettyprint notranslate"><div class="highlight"><pre><span></span>    result = []
    i = 0
start:
    numPeople = length(people)
    if i &gt;= numPeople goto finished
    p = people[i]
    nameLength = length(p.name)
    if nameLength &lt;= 5 goto nextOne
    upperName = toUpper(p.name)
    addToList(result, upperName)
nextOne:
    i = i + 1
    goto start
finished:
    return sort(result)
</pre></div>
</div>
</section>
<section id="structured-programming">
<h3>Structured Programming<a class="headerlink" href="#structured-programming" title="Permalink to this heading"></a></h3>
<p>[Structured programming]{.dfn} is a kind of imperative programming where
control flow is defined by nested loops, conditionals, and subroutines,
rather than via gotos. Variables are generally local to blocks (have
lexical scope).</p>
<div class="highlight-prettyprint notranslate"><div class="highlight"><pre><span></span>result = [];
for i = 0; i &lt; length(people); i++ {
    p = people[i];
    if length(p.name)) &gt; 5 {
        addToList(result, toUpper(p.name));
    }
}
return sort(result);
</pre></div>
</div>
<p>Early languages emphasizing structured programming: Algol 60, PL/I,
Algol 68, Pascal, C, Ada 83, Modula, Modula-2. Structured programming as
a discipline is sometimes though to have been started by a famous letter
by Edsger Dijkstra entitled <a class="reference external" href="http://david.tribble.com/text/goto.html">Go to Statement Considered
Harmful</a>.</p>
</section>
<section id="object-oriented-programming">
<h3>Object Oriented Programming<a class="headerlink" href="#object-oriented-programming" title="Permalink to this heading"></a></h3>
<p>OOP is based on the sending of [messages]{.dfn} to objects. Objects
respond to messages by performing operations, generally called
[methods]{.dfn}. Messages can have arguments. A society of objects, each
with their own local memory and own set of operations has a different
feel than the monolithic processor and single shared memory feel of non
object oriented languages.</p>
<p>One of the more visible aspects of the more pure-ish OO languages is
that conditionals and loops become messages themselves, whose arguments
are often blocks of executable code. In a Smalltalk-like syntax:</p>
<div class="highlight-prettyprint notranslate"><div class="highlight"><pre><span></span>result := List new.
people each: [:p |
  p name length greaterThan: 5 ifTrue: [result add (p name upper)]
]
result sort.
^result
</pre></div>
</div>
<p>This can be shortened to:</p>
<div class="highlight-prettyprint notranslate"><div class="highlight"><pre><span></span>^people filter: [:p | p name length greaterThan: 5] map: [:p | p name upper] sort
</pre></div>
</div>
<p>Many popular languages that call themselves OO languages (e.g., Java,
C++), really just take some elements of OOP and mix them in to
imperative-looking code. In the following, we can see that <code class="docutils literal notranslate"><span class="pre">length</span></code> and
<code class="docutils literal notranslate"><span class="pre">toUpper</span></code> are methods rather than top-level functions, but the <code class="docutils literal notranslate"><span class="pre">for</span></code> and
<code class="docutils literal notranslate"><span class="pre">if</span></code> are back to being control structures:</p>
<div class="highlight-prettyprint notranslate"><div class="highlight"><pre><span></span>result = []
for p in people {
    if p.name.length &gt; 5 {
        result.add(p.name.toUpper);
    }
}
return result.sort;
</pre></div>
</div>
<p>The first object oriented language was Simula-67; Smalltalk followed
soon after as the first “pure” object-oriented language. Many languages
designed from the 1980s to the present have labeled themselves
object-oriented, notably C++, CLOS (object system of Common Lisp),
Eiffel, Modula-3, Ada 95, Java, C#, Ruby.</p>
</section>
<section id="declarative-programming">
<h3>Declarative Programming<a class="headerlink" href="#declarative-programming" title="Permalink to this heading"></a></h3>
<p>Control flow in [declarative programming]{.dfn} is <em>implicit</em>: the
programmer states only <em>what</em> the result should look like, <strong>not</strong> how
to obtain it.</p>
<div class="highlight-{.prettyprint .lang-sql} notranslate"><div class="highlight"><pre><span></span>select upper(name)
from people
where length(name) &gt; 5
order by name
</pre></div>
</div>
<p>No loops, no assignments, etc. Whatever engine that interprets this code
is just supposed go get the desired information, and can use whatever
approach it wants. (The logic and constraint paradigms are generally
declarative as well.)</p>
</section>
<section id="functional-programming">
<h3>Functional Programming<a class="headerlink" href="#functional-programming" title="Permalink to this heading"></a></h3>
<p>In [functional programming]{.dfn}, control flow is expressed by
combining function calls, rather than by assigning values to variables:</p>
<div class="highlight-{.prettyprint .lang-ml} notranslate"><div class="highlight"><pre><span></span>sort(
  fix(λf. λp.
    if(equals(p, emptylist),
      emptylist,
      if(greater(length(name(head(p))), 5),
        append(to_upper(name(head(p))), f(tail(p))),
        f(tail(people)))))(people))
</pre></div>
</div>
<p>Yikes! We’ll describe that later. For now, be thankful there’s usually
syntactic sugar:</p>
<div class="highlight-{.prettyprint .lang-ml} notranslate"><div class="highlight"><pre><span></span>let
    fun uppercasedLongNames [] = []
      | uppercasedLongNames (p :: ps) =
          if length(name p) &gt; 5 then (to_upper(name p))::(uppercasedLongNames ps)
          else (uppercasedLongNames ps)
in
    sort(uppercasedLongNames(people))
</pre></div>
</div>
<p>Huh? That still isn’t very pretty. Why do people like this stuff? Well
the real power of this paradigm comes from passing functions to
functions (and returning functions from functions).</p>
<div class="highlight-prettyprint notranslate"><div class="highlight"><pre><span></span>sort(
    filter(λs. length s &gt; 5,
        map(λp. to_upper(name p),
            people)))
</pre></div>
</div>
<p>We can do better by using the cool <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code> operator. Here <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|&gt;</span> <span class="pre">f</span></code> just
means <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>. The operator has very low precedence so you can read
things left-to-right:</p>
<div class="highlight-prettyprint notranslate"><div class="highlight"><pre><span></span>people |&gt; map (λp. to_upper (name p)) |&gt; filter (λs. length s &gt; 5) |&gt; sort
</pre></div>
</div>
<p>Let’s keep going! Notice that you wouldn’t write <code class="docutils literal notranslate"><span class="pre">map(λx.</span> <span class="pre">square(x))</span></code>,
right? You would write <code class="docutils literal notranslate"><span class="pre">map(square)</span></code>. We can do something similar above,
but we have to use function composition, you know, <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">o</span> <span class="pre">g)x</span></code> is
<code class="docutils literal notranslate"><span class="pre">f(g(x))</span></code>, so:</p>
<div class="highlight-prettyprint notranslate"><div class="highlight"><pre><span></span>people |&gt; map (to_upper o name) |&gt; filter (λs. length s &gt; 5) |&gt; sort
</pre></div>
</div>
<p>Here are three things to read to get the gist of functional programming:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://blog.jenkster.com/2015/12/what-is-functional-programming.html">Kris Jenkins’
article</a></p></li>
<li><p><a class="reference external" href="https://www.fpcomplete.com/blog/2017/04/pure-functional-programming">Chris Done’s two-part
article</a></p></li>
<li><p><a class="reference external" href="http://www.joelonsoftware.com/items/2006/08/01.html">Joel Spolsky’s article on map and
reduce</a></p></li>
</ul>
<p>With functional programming:</p>
<ul class="simple">
<li><p>There are no commands, only side-effect free expressions</p></li>
<li><p>Code is much shorter, less error-prone, and much easier to prove
correct</p></li>
<li><p>There is more inherent parallelism, so good compilers can produce
faster code</p></li>
</ul>
<p>Some people like to say:</p>
<ul class="simple">
<li><p><em>Functional, or Applicative, programming</em> is programming without
assignment statements: one just applies functions to arguments.
Examples: Scheme, Haskell, Miranda, ML.</p></li>
<li><p><em>Function-level programming</em> does away with the variables; one
combines functions with [functionals]{.dfn}, a.k.a.
[combinators]{.dfn}. Examples: FP, FL, J.</p></li>
</ul>
<p>::: exercise
<strong>Exercise</strong>: Write the above example in Miranda, ML, and J.
:::</p>
<p>::: exercise
<strong>Exercise</strong>: Research the following programming styles and state how
they are similar and how they are different from each other: (a)
Stack-based, (b) Concatenative, (c) Point-free, (d) Tacit.
:::</p>
<p>Many languages have a neat little thing called [comprehensions]{.dfn}
that combine map and filter.</p>
<div class="highlight-{.prettyprint .lang-py} notranslate"><div class="highlight"><pre><span></span>sorted(p.name.upper() for p in people if len(p.name) &gt; 5)
</pre></div>
</div>
</section>
<section id="logic-and-constraint-programming">
<h3>Logic and Constraint Programming<a class="headerlink" href="#logic-and-constraint-programming" title="Permalink to this heading"></a></h3>
<p>[Logic programming]{.dfn} and [constraint programming]{.dfn} are two
paradigms in which programs are built by setting up relations that
specify [facts]{.dfn} and inference [rules]{.dfn}, and asking whether or
not something is true (i.e. specifying a [goal]{.dfn}.) Unification and
backtracking to find solutions (i.e.. satisfy goals) takes place
automatically.</p>
<p>Languages that emphasize this paradigm: Prolog, GHC, Parlog, Vulcan,
Polka, Mercury, Fnil.</p>
<p>::: exercise
<strong>Exercise</strong>: Write the running example in Prolog.
:::</p>
</section>
</section>
<section id="languages-and-paradigms">
<h2>Languages and Paradigms<a class="headerlink" href="#languages-and-paradigms" title="Permalink to this heading"></a></h2>
<p>One of the characteristics of a language is its support for particular
programming paradigms. For example, Smalltalk has direct support for
programming in the object-oriented way, so it might be called an
object-oriented language. OCaml, Lisp, Scheme, and JavaScript programs
tend to make heavy use of passing functions around so they are called
“functional languages” despite having variables and many imperative
constructs.</p>
<p>There are two very important observations here:</p>
<ul class="simple">
<li><p>Very few languages implement a paradigm 100%. When they do, they are
[pure]{.dfn}. It is incredibly rare to have a “pure OOP” language or
a “pure functional” language. A lot of languages have a few escapes;
for example in OCaml, you will program with functions 90% or more of
the time, but if you need state, you can get it. Another example:
very few languages implement <a class="reference external" href="http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented">OOP the way Alan Kay envisioned
it</a>.</p></li>
<li><p>A lot of languages will facilitate programming in one or more
paradigms. In Scala you can do imperative, object-oriented, and
functional programming quite easily. If a language is <em>purposely</em>
designed to allow programming in many paradigms is called a
[multi-paradigm language]{.dfn}. If a language only <em>accidentally</em>
supports multiple paradigms, we don’t have a special word for that.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Claus Bove.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>